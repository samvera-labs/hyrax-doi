# frozen_string_literal: true

require 'maremma'

## Set a default host for urls generated by the DOI registrars (if necessary)
Rails.application.routes.default_url_options[:host] = 'localhost:3000'

## Remote identifiers configuration
# Add registrar implementations by uncommenting and adding to the hash below.
# See app/services/hyrax/identifier/registrar.rb for the registrar interface
Hyrax.config.identifier_registrars = { datacite: Hyrax::DOI::DataCiteRegistrar }

## For DataCite DOIs
# Test mode will use the DataCite test environment
Hyrax::DOI::DataCiteRegistrar.mode = :test # Possible options are [:production, :test]
Hyrax::DOI::DataCiteRegistrar.prefix = ENV['DATACITE_PREFIX']
Hyrax::DOI::DataCiteRegistrar.username = ENV['DATACITE_USERNAME']
Hyrax::DOI::DataCiteRegistrar.password = ENV['DATACITE_PASSWORD']

## Bug-handling overrides
require_dependency Pathname.new(Gem.loaded_specs['bolognese'].full_gem_path).join('lib', 'bolognese', 'doi_utils').to_s

Bolognese::DoiUtils.module_eval do
  def doi_resolver(doi, options = {})
    sandbox = Array(/handle.stage.datacite.org/.match(doi)).last
    sandbox.present? || options[:sandbox] ? "https://handle.test.datacite.org/" : "https://doi.org/"
  end

  def doi_api_url(doi, options = {})
    sandbox = Array(/handle.stage.datacite.org/.match(doi)).last
    sandbox.present? || options[:sandbox] ? "https://api.test.datacite.org/dois/#{doi_from_url(doi)}?include=media,client"  : "https://api.datacite.org/dois/#{doi_from_url(doi)}?include=media,client"
  end
end

# Name type is ignored/clobbered by bolognese in a confused attempt to parse 
# it into an attribute. The result is name_type == nil
# This override will fix that
require_dependency Pathname.new(Gem.loaded_specs['bolognese'].full_gem_path).join('lib', 'bolognese', 'author_utils').to_s

Bolognese::AuthorUtils.module_eval do

  def get_one_author(author)
    # author is a string
    author = { "creatorName" => author } if author.is_a?(String)

    # malformed XML
    return nil if author.fetch("creatorName", nil).is_a?(Array)

    name = parse_attributes(author.fetch("creatorName", nil)) ||
           parse_attributes(author.fetch("contributorName", nil))
    given_name = parse_attributes(author.fetch("givenName", nil))
    family_name = parse_attributes(author.fetch("familyName", nil))
    name = cleanup_author(name)
    name = [family_name, given_name].join(", ") if family_name.present? && given_name.present?
    contributor_type = parse_attributes(author.fetch("contributorType", nil))

    # keep name_type simple here, it gets parsed as an attribute further down the line
    name_type = parse_attributes(author.fetch("nameType",nil))

    name_identifiers = Array.wrap(author.fetch("nameIdentifier", nil)).map do |ni|
      if ni["nameIdentifierScheme"] == "ORCID"
        {
          "nameIdentifier" => normalize_orcid(ni["__content__"]),
          "schemeUri" => "https://orcid.org",
          "nameIdentifierScheme" => "ORCID" }.compact
      elsif ni["schemeURI"].present?
        {
          "nameIdentifier" => ni["schemeURI"].to_s + ni["__content__"].to_s,
          "schemeUri" => ni["schemeURI"].to_s,
          "nameIdentifierScheme" => ni["nameIdentifierScheme"] }.compact
      else
        {
          "nameIdentifier" => ni["__content__"],
          "schemeUri" => nil,
          "nameIdentifierScheme" => ni["nameIdentifierScheme"] }.compact
      end
    end.presence

    author = { "nameType" => name_type,
               "name" => name,
               "givenName" => given_name,
               "familyName" => family_name,
               "nameIdentifiers" => name_identifiers,
               "affiliation" => get_affiliations(author.fetch("affiliation", nil)),
               "contributorType" => contributor_type }.compact

    return author if family_name.present?

    if is_personal_name?(author)
      Namae.options[:include_particle_in_family] = true
      names = Namae.parse(name)
      parsed_name = names.first

      if parsed_name.present?
        given_name = parsed_name.given
        family_name = parsed_name.family
        name = [family_name, given_name].join(", ")
      else
        given_name = nil
        family_name = nil
      end

      { "nameType" => "Personal",
        "name" => name,
        "givenName" => given_name,
        "familyName" => family_name,
        "nameIdentifiers" => Array.wrap(name_identifiers),
        "affiliation" => Array.wrap(author.fetch("affiliation", nil)),
        "contributorType" => contributor_type }.compact
    else
      { "nameType" => name_type,
        "name" => name,
        "nameIdentifiers" => Array.wrap(name_identifiers),
        "affiliation" => Array.wrap(author.fetch("affiliation", nil)),
        "contributorType" => contributor_type }.compact
    end
  end
end

## Fix UTF8 encoding bug https://github.com/datacite/maremma/issues/17
Maremma.class_eval do
  def self.parse_response(string, options = {})
    string = string.dup
    string =
      if options[:skip_encoding]
        string
      else
        string.force_encoding('utf-8').encode(
          Encoding.find("UTF-8"),
          invalid: :replace,
          undef: :replace,
          replace: "?"
        )
      end
    return string if options[:raw]

    from_json(string) || from_xml(string) || from_string(string)
  end
end

# Override Hyrax::Identifier::Dispatcher.assign_for (Hyrax 2.9.6)
# to set official_url (official_link for some reason) with doi in 
# certain conditions
Hyrax::Identifier::Dispatcher.class_eval do

      ##
      # Assigns an identifier to the object.
      #
      # This involves two steps:
      #   - Registering the identifier with the registrar service via `registrar`.
      #   - Storing the new identifier on the object, in the provided `attribute`.
      #
      # @note the attribute for identifier storage must be multi-valued, and will
      #  be overwritten during assignment.
      #
      # @param attribute [Symbol] the attribute in which to store the identifier.
      #   This attribute will be overwritten during assignment.
      # @param object    [ActiveFedora::Base, Hyrax::Resource] the object to assign an identifier.
      #
      # @return [ActiveFedora::Base, Hyrax::Resource] object
  def assign_for(object:, attribute: :identifier)
    record = registrar.register!(object: object)
    object.public_send("#{attribute}=".to_sym, [record.identifier])
    # Work is public and the status when public (annoyingly the gem's 
    # public? method is private) is either findable or registered
    if object.official_link.blank? and object.visibility == Hydra::AccessControls::AccessRight::VISIBILITY_TEXT_VALUE_PUBLIC and object.doi_status_when_public.in?(['registered', 'findable'])
      object.official_link="https://doi.org/#{record.identifier}"
    end
    object
  end
end

# Forces DataCiteRegistrar to initializew a new client everytime. 
# A fix for #245 https://github.com/scientist-softserv/britishlibrary/issues/245
# Prevents leaching of datacite config between tenants when minting DOIs by ensuring
# that the datacite credentials always come from the account that kicked the job off
Hyrax::DOI::DataCiteRegistrar.class_eval do

  def initialize(builder: nil)
    current_tenant = Apartment::Tenant.current
    datacite_endpoint ||= Account.find_by(tenant: current_tenant).data_cite_endpoint
    self.username = datacite_endpoint.username
    self.password = datacite_endpoint.password
    self.prefix = datacite_endpoint.prefix
    self.mode = datacite_endpoint.mode
    super(builder: Hyrax::Identifier::Builder.new(prefix: self.prefix))
  end

  def client 
    Hyrax::DOI::DataCiteClient.new(username: self.username, password: self.password, prefix: self.prefix, mode: self.mode)
  end

end

# TODO: determine if embargo doi logic from BL is needed
# Hyrax::Actors::EmbargoActor.prepend(Hyrax::Actors::EmbargoActorDecorator)
